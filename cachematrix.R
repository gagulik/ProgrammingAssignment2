## This is the Assignement 2 for "R programming" course by John Hopkins University
## and Coursera due by Week 3
## The assignement is to write two functions that would cache the inversion of a matrix
## which is quite costly operation
## Student: S.Azari
##
## Function prototypes are based on samples supplied by Dr. Roger D. Peng for this assignement.
## To test the functionality please use follwing lines of a code:
## x<-matrix(rnorm(25),nrow=5)
## smartX<-makeCacheMatrix(x)
## cacheSolve(smartX)
## cacheSolve(smartX)
## cacheSolve(smartX)
##
## First line will create a 5x5 matrix of normal random variables
## Second line will create a smart version of that matrix enhanced with the ability
## to cache its inversion
## Third line will execute inversion first time and cache it
## Subsequent lines will test that values come from cache
## 
## Although Week 3 covers lots of debugging and assignement states to assume that matrice
## will be always inversible - the assignement does not explicitly
## summons students to enrich the code with debugging statements or argument error checks.
## For example, supplying non-square matices or singular systems (e.g. generated by code
## x<-matrix(c(1:25),nrow=5) will force functions to crash.
##

## The first function, `makeCacheMatrix` creates a special "matrix", which is
## really a list containing a function to

## 1.  set the value of the matrix
## 2.  get the value of the matrix
## 3.  set the value of the solve - matrix inversion
## 4.  get the value of the solve

makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function() x
        setsolve <- function(solve) m <<- solve
        getsolve <- function() m
        list(set = set, get = get,
             setsolve = setsolve,
             getsolve = getsolve)        
}


## Function cacheSolve
## The following function calculates the inversion of the special "matrix"
## created with the above makeCacheMatrix function. However, it first checks to see if the
## inversion has already been calculated. If so, it `get`s the inversion from the
## cache and skips the computation. Otherwise, it inverses the matrix
## and sets the value of a cache via the `setsolve`
## function.

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        m <- x$getsolve()
        if(!is.null(m)) {
                message("cacheSolve() getting cached data")
                return(m)
        }
        data <- x$get()
        message("cacheSolve() calculating matrix inversion")
        m <- solve(data, ...)
        message("cacheSolve() setting cached data")
        x$setsolve(m)
        m
}
